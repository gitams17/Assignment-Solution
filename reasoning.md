# Project Reasoning & Approach

## 1. Architectural Approach
I adopted a **Clean Architecture (Layered)** pattern to ensure separation of concerns, scalability, and testability. The project is structured into three distinct layers:

- **Handler Layer (`/internal/handler`):** Manages HTTP requests, parsing, and input validation. It does not contain business logic.
- **Service Layer (`/internal/service`):** Contains the core business logic (e.g., dynamic age calculation). It acts as the bridge between the HTTP handler and the database.
- **Repository Layer (`/internal/repository`):** Handles direct database interactions. This layer uses code generated by SQLC to ensure type safety and performance.

## 2. Key Technical Decisions

### **Why SQLC over GORM?**
I chose **SQLC** instead of a traditional ORM like GORM.
- **Type Safety:** SQLC generates Go code from raw SQL, catching errors at compile time rather than runtime.
- **Performance:** It avoids the reflection overhead of ORMs, resulting in faster query execution.
- **Control:** Writing raw SQL allows for optimized queries (like specific `LIMIT` and `OFFSET` for pagination) without fighting the abstraction of an ORM.

### **Why Fiber?**
I selected **GoFiber** as the web framework because:
- It is one of the fastest Go web frameworks.
- Its syntax is similar to Express.js, making the code readable and concise.
- It has built-in support for middleware, which I used for logging and request ID tracking.

### **Dynamic Age Calculation**
The requirement was to store `DOB` but return `Age`.
- **Decision:** I decided **not** to store `Age` in the database because it is a volatile field that changes daily.
- **Implementation:** The `Age` is calculated dynamically in the **Service Layer** at the moment of the request. This ensures the data is always accurate without needing background jobs to update database rows.

### **Structured Logging (Uber Zap)**
I used **Uber Zap** instead of the standard library `log`.
- **Reasoning:** In a production environment, logs need to be machine-readable (JSON) for tools like Datadog or ELK Stack. Zap provides high-performance, structured logging out of the box.

## 3. Bonus Implementations
To ensure the application is production-ready, I implemented several additional features:
- **Dockerization:** A multi-stage `Dockerfile` to keep the final image small (using Alpine Linux) and a `docker-compose` setup for one-click deployment.
- **Pagination:** Added `page` and `limit` query parameters to the List endpoint to prevent loading massive datasets into memory.
- **Middleware:** Added Request ID tracing and duration logging to help debug performance issues.
- **Unit Testing:** Wrote unit tests for the critical age calculation logic to ensure edge cases (e.g., leap years, birthdays not yet passed) are handled correctly.
